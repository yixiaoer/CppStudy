# Chapter 2 记录
## C++ 程序的结构特性
* 一个面向对象的 C++ 程序一般由**类的声明**和**类的使用**两大部分组成
* 类的使用部分一般由主函数及有关子函数组成
* 在 C++ 程序中，程序设计始终围绕“类”展开，通过声明类，构建了程序所要完成的功能，体现了面向对象程序设计的思想

## C++ 的输入与输出
* scanf 和 printf 仍然可用
* cin 和 cout
* 换行操作符 endl

## const 修饰符
[const 总结](https://www.cnblogs.com/jiabei521/p/3335676.html)
### 用 const 定义常量，可以把对象转变成常数对象
* 利用 const 进行修饰的变量的值在程序的任意位置将不能再被修改，就如同常数一样使用
* 与 "#define" 定义的常量有所不同，const 定义的常量可以有自己的数据类型，这样 C++ 的编译程序可以进行更加严格的类型检查，具有良好的编译时的检测性
* 任何修改该变量的尝试都会导致编译错误，**因为常量在定以后就不能被修改，所以定义时必须初始化**
* 对于类中的 const 常数变量，需通过初始化列表进行初始化
### const 也可以与指针一起使用
* 指向常量的指针
是指一个指向常量的指针变量
```C++
const char* name = "chen" ;
```
这个语句的含义为：声明一个名为 name 的指针变量，它指向一个字符型常数，初始化 name 为指向字符串“chen”
由于使用了 const，不允许改变指针所致地址中的常量
* 常指针
把指针所指的地址，而不是指向的对象声明为常量
* 指向常量的常指针
这个指针本身不改变，其所指向的地址中的数据也不能改变
### 函数的形参也可以用 const 说明
当用于保证形参在该函数内部不被改变，即在函数中对其操作只许读，不许写

## 内联函数
在函数说明前冠以关键字“inline”，该函数就被声明为内联函数，又称内置函数
* 引入内联函数主要是为了消除函数调用时的系统开销，以提高运行速度
* 内联函数在第一次被调用之前必须进行完整的定义，否则编译器无法知道应该插入什么代码
* 内联函数体内一般不能含有复杂的控制语句
* 使用内联函数是一种用空间换时间的措施，若内联函数较长且调用较频繁时，程序将加长很多；如果将一个复杂的函数定义为内联函数，反而会使程序代码加长很多，增大开销
* C++ 的内联函数与 C 中带参宏定义 #define 有些相似，但不完全相同，宏定义是在编译前由预编译程序对其进行预处理的，它只做简单的**字符置换**，而**不做语法检查**，往往会出现意想不到的错误（e.g. 6definefun.cpp）

## 带有默认参数的函数
* 一般情况下，实参个数应与形参个数相同，但 C++ 允许实参个数与形参个数不同
* 方法，在说明函数原型时（若没有说明函数的原型，则应在函数定义时），为一个或多个形参指定默认值，以后调用此函数时，若省略其中某一实参，C++ 自定义默认值作为相应参数值
* 当进行函数调用时，编译系统按从左向右顺序将实参与形参相结合，若未指定足够的实参，则编译系统按顺序用函数原型中的形参默认值来补足所缺少的实参；则在调用含有默认参数的函数时，实参的个数可以与形参不同

## 函数的重载
* 在 C++ 中函数可以重载，这意味着只要函数参数的类型不同，或者参数的个数不同，或者二者兼有之，两个或者两个以上的函数可以使用相同的函数名，当两个或者两个以上的函数共用一个函数名时，称为函数的重载，被重载的函数称为重载函数
* 当用户调用这些函数时，编译系统就会根据实参的类型来确定调用哪个重载函数
* 调用重载函数时，函数返回值类型不再参数匹配检查之列，因此，若两个函数的参数个数和类型都相同，而只有返回值类型不同，则不允许重载
* 函数的重载与带默认值的函数一起使用时，有可能引起二义性
* 在函数调用时，若给出的实参和形参类型不相符，编译器会自动地做类型转换工作，有可能产生不可识别的错误

## 作用域运算符“：：”
* 通常情况下，如果有两个同名变量，一个是全局的，一个是局部的，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量
* 若要对被屏蔽的同名全局变量进行访问，可以在其前加上“::”，即作用域运算符可以用来解决局部变量和全局变量的重名问题（e.g. 11aver.cpp)

## 无名联合
* 无名联合是 C++ 中的一种特殊联合，它在关键字 union 后面没有给出联合名，它可使一组数据成员共享同一内存地址
* 在访问无名变量时，不可直接访问无名联合变量，而应该访问联合变量中的成员

## 强制类型转换
int i = 10;
* `double x = (double)i ;`
* `double x = double(i);//推荐使用这种，更像调用了一个函数`

## 运算符 new 和 delete
* 为了与 C 语言兼容，C++ 中仍保留了 malloc 和 free，但使用运算符 new 和 delete 可以更好、更简单地进行内存的分配和释放
* 在程序运行过程中，运算符 **new** 从称为堆的一块自由存储区中为程序分配一块与类型字节数相适应的内存空间，并将该块内存的首地址存于指针变量中
   * 运算符用于内存分配的最基本形式 `指针变量名 = new 类型;`
    ```C++
    int *p;  //定义一个整型指针
    p = new int； //new 动态分配存放一个整数的存储空间，并将其首地址符给指针变量 p
    ```
   * 使用 new 可数组动态分配内存空间 ，这时需要在类型名后面缀上数组大小
   * new 可在为简单变量分配内存的同时，进行初始化
   * 使用 new 动态分配内存时，若没有足够的内存满足分配要求，则动态分配空间失效，有些编译系统将返回空指针 NULL
   * 用 new 分配的存储空间不会自动释放，只能通过 delete 释放，因此要**适时释放动态分配的存储空间**
* 运算符 **delete** 用于释放运算符 new 分配的存储空间
   * 该运算符释放存储空间的基本形式为 `delete p;`
   * 释放动态分配的数组存储区时，可用这种格式：`delete [] 指针变量名`

## 引用
* 建立引用的作用是为变量另起一个名字，变量的应用通常被认为是变量的别名
* 当声明一个引用时，必须同时用另一个变量的名字来将它初始化，即声明它代表哪一个变量是哪一个变量的别名，这样对一个引用的所有操作实际上都是对其所代表的变量的操作
* 声明一个引用
`类型 &引用名 = 已定义的变量名;`
其中 `&` 是引用声明符，此时它不代表地址，对变量声明一个引用并不另外开辟内存单元，变量和引用占用内存的同一位置，即**两者的值同步变化，且使用内存的同一地址**
* 引用名可以使用任何合法的变量名
* 为引用提供的初始值可以是一个变量或者另一个引用，但引用在初始化之后就不能再被重新声明为另一个变量的引用（别名）
```C++
int i = 5 ,k = 1;    //定义整型变量 i,k
int &j1 = i ;  //声明 j1 是整型变量 i 的引用（别名）
int &j2 = j1 ; //声明 j2 是整型引用 j1 的引用（别名）
j1 = &k;  //是错误的，不能重新声明已经初始化了的引用 j1 作为整型变量 k 的引用
```
* 引用作为函数参数，产生的效果同采用指针变量作为函数参数的效果是一样的，但是引用作为函数参数更清楚简单，采用这种方法，函数的形参前不需要间接引用运算符“*”，函数引用时实参是变量（18.cpp）
* 引用可以返回函数的值（19.cpp）