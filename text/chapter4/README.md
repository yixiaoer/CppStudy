# Chapter 4 派生类与继承
继承是面向对象程序设计的一个重要特性，允许在已有类的基础上创建新的类
新的类可以从一个或多个已有类中继承函数和数据，而且可以重新定义加进新的数据和函数，从而形成类的层次或等级，其中已有类称为基类或父类，在它基础上建立的新类称为派生类或子类



## 派生类的概念

* 一些说明

  * 类的继承就是新的类从已有类那里得到已有的特性
  * 从已有类产生新类的过程就是类的派生
  * 类的继承和派生机制是程序员无需修改已有类，只需在已有类的基础上，通过增加少量代码或修改少量代码的方法得到新的类，能较好解决代码重用的问题
  * 派生类同样也可以作为基类派生出新的类，这样就形成了类的层次结构
  * 关键字 protected，将相关的数据成员说明成保护成员，保护成员可以被本类的成员函数访问，也可以被本类的派生类的成员函数访问，而类以外的任何访问都是非法的，即它是半隐蔽的

* 派生类的声明

  举例：

  ```C++
  class Person{                              //声明基类 Person
    public:
      void print()
      {
          cout<<"name:"<<name<<endl;
          cout<<"age:"<<age<<endl;
          cout<<"sex:"<<sex<<endl;
      }
      
    protected:
      string name;
      int age;
      char sex;
  };
  
  char Employee: public Person{             //声明派生类 Employee 公有继承了基类 Person
    public:
      void public1()                        //新增加的成员函数
      {
          print();
          cout<<"department:"<<department<<endl;
          cout<<"salary:"<<salary<<endl;
      }
      
    private:
      string department;                    //新增加的数据成员
      float salary;                         //新增加的数据成员
  };
  ```

  一般格式

  ```C++
  Class 派生类名:[继承方式]基类名{
      派生类新增的数据成员和成员函数
  };
  ```

  继承方式规定了如何访问从基类继承的成员，可以是关键字 private、public 或 protected，分别表示私有继承、公有继承和保护继承

  如果不显式地给出继承方式关键字，系统默认为私有继承（private）

* 派生类的构成

  * 派生类除了可以从基类继承成员外，还可以增加自己的数据成员和成员函数，这些新增的成员正是派生类不同于基类的关键所在，是派生对基类的发展

  * 构造一个派生类一般包括以下 3 部分工作

    * 派生类从基类接受成员

      在 C++ 的类继承中，派生类把基类的全部成员（**除构造函数和析构函数之外**）接收过来

    * 调整从基类接受来的成员

      * 派生类不能对接受基类的成员进行选择，但是可以对这些成员进行某些调整

      * 调整的两个方面

        * 改变基类成员在派生类中的**访问属性**

          主要是通过派生类声明时的继承方式来控制

        * 派生类可以对基类的成员进行重定义

          * 在派生类中声明一个与基类成员同名的成员，则派生类中的新成员会覆盖基类的同名成员
          * 这时在派生类中或者通过派生类对象，直接使用成员名就只能访问到派生类中声明的同名成员
          * 如果是成员函数，不仅应是函数名相同，而且**函数的参数列表也应相同**，如果不同，则称派生类**重载**了基类的成员函数，而不是覆盖了基类的同名函数

    * 在派生类中增加新的成员

      * 体现了派生类对基类功能的扩展，是继承和派生机制的核心

  * 在继承过程中，基类的构造函数和析构函数是不能被继承的，因此在声明派生类时，一般需要在派生类中定义新的构造函数和析构函数

  * 基类成员在派生类中的访问属性**<font color=#CA9E92>（即派生出来的子类对于父类中各成员的访问属性）</font>**

    * **基类的私有成员不允许派生类继承**，因此在派生类中是不可以直接访问的（但是不能直接访问不代表不能访问）

    * 派生了可以继承基类中除了构造函数和析构函数之外的成员，且这些成员的**访问属性在派生过程中是可以调整的**

    * 基类成员的访问属性

      <table><tr><td>基类中的成员</td><td>在公有派生类中的访问属性</td><td>在私有派生类中的访问属性</td><td>在保护派生类中的访问属性</td></tr>
          <tr><td>私有成员<br>公有成员<br>保护成员</td><td>不可直接访问<br>公有<br>保护</td><td>不可直接访问<br>私有<br>私有</td><td>不可直接访问<br>保护<br>保护</td></tr>
      </table>

  * 派生类对基类成员的访问规则**<font color=#CA9E92>（即派生出来的子类对父类中各成员的访问规则）</font>**

    * 主要访问形式

      * 内部访问：由派生类中新增的成员函数对基类继承来的成员的访问
      * 对象访问：在派生类外部，通过派生类的对象对从基类继承来的对象的访问

    * 具体三种继承方式下，派生类对基类成员的访问规则

      * **私有继承的访问规则**（e.g. 0.cpp，1.cpp）

        <table><th colspan="2">基类中的成员</th><th>私有成员</th><th>公有成员</th><th>保护成员</th>
            <tr><td>访问方式</td><td>内部访问<br>对象访问</td><td>不可访问<br>不可访问</td><td>可访问<br>不可访问</td><td>可访问<br>不可访问</td></tr>
        </table>

        * 基类的公有成员和保护成员被继承后作为派生类的**<font color=#EA9921>私有成员</font>**（**<font color=#EA9921>➡可以内部访问，不可对象访问</font>**）

        * 基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的成员函数可以直接访问它们，但是在类外部通过派生类的对象无法访问

        * 经过私有继承之后，所有基类成员都成为了派生类的私有成员或不可直接访问的成员，如果进一步派生，基类的全部成员都无法在新的派生类中被访问

          因此，私有继承之后，基类的成员无法在以后的派生类中再发挥作用，实际上相当于终止了基类功能的继续派生，因此私有继承的实际应用很少

      * 公有继承的访问规则（e.g. 2.cpp）

        <table><th colspan="2">基类中的成员</th><th>私有成员</th><th>公有成员</th><th>保护成员</th>
            <tr><td>访问方式</td><td>内部访问<br>对象访问</td><td>不可访问<br>不可访问</td><td>可访问<br>可访问</td><td>可访问<br>不可访问</td></tr>
        </table>

        * 基类的公有成员被继承到派生类中仍作为派生类的公有成员，派生类的成员函数可以访问它们；在类的外部，也可以通过派生类的对象访问它们
        * 基类的被保护成员被继承到派生类后仍作为派生类的被保护成员，派生类的成员函数可以直接访问，但不可以对象访问

      * 保护继承的访问规则（e.g. 3.cpp）

        <table><th colspan="2">基类中的成员</th><th>私有成员</th><th>公有成员</th><th>保护成员</th>
            <tr><td>访问方式</td><td>内部访问<br>对象访问</td><td>不可访问<br>不可访问</td><td>可访问<br>不可访问</td><td>可访问<br>不可访问</td></tr>
        </table>基类的公有成员和保护成员被继承到派生类中都作为派生类的保护成员，派生类的其他成员可以直接访问它们，但是在类的外部，不能通过派生类的对象来访问它们



## 派生类的构造函数与析构函数

* 一些说明

  * 派生类继承了基类的成员，实现了原有代码的重用，更重要是的实现了代码的扩充，只有在派生类中通过添加新的成员，加入新的功能，类的派生才有意义
  * 基类的构造函数与析构函数不能被继承，在派生类中如果对派生类新增的成员进行初始化，就需要加入派生类的构造函数
  * 与此同时，对所有从基类继承下来的成员的初始化工作，还是由基类的构造函数完成的，但我们必须在派生类中对基类的构造函数所需要的参数进行设置
  * 同样对撤销派生类对象时的扫尾、清理工作也需要加入新的析构函数来完成

* 派生类构造函数和析构函数的执行顺序（e.g. 4.cpp）

  * 当创建派生类对象时，首先执行基类的构造函数，随后再执行派生类的构造函数
  * 当撤销派生类对象时，首先执行派生类的析构函数，随后再执行基类的析构函数

* 派生类构造函数和析构函数的构造规则

  * 简单的派生类的构造函数

    * 但基类的构造函数没有参数，或没有显式定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数

    * 派生类不能继承基类中的构造函数和析构函数，但基类含有带参数的构造函数时，派生类必须定义构造函数，以提供把参数传递给基类构造函数的途径（e.g. 5.cpp）

    * 一般格式：

      ```C++
      派生类名(参数总表):基类名(参数表){//基类名后面跟的参数表中是实参而不是形参
          派生类新增数据成员的初始化语句
      }
      ```

    * 可以将派生类构造函数定义在类的外部，而在类体内只写该函数的声明

    * 若基类使用默认构造函数或不带参数的构造函数，则在派生类中定义构造函数时可以略去`“:基类构造函数名(参数表)”`，此时若派生类不需要构造函数，则可不定义派生类构造函数

    * 当基类构造函数不带函数时，派生类不一定需要定义构造函数，但当基类的构造函数哪怕只有一个参数，它所有的派生类都必须定义构造函数，甚至所定义的派生类构造函数的函数体可能为空，仅仅起参数的传递作用

  * 派生类的析构函数

  * 含有对象成员（子对象）的派生类的构造函数

    * 当派生类中含有内嵌的对象成员（子对象）时，其构造函数的一般形式为：

      ```C++
      派生类名(参数总表):基类名(参数表0),对象成员名(参数表1),...
      {
          派生类新增成员的初始化语句
      }
      ```

    * 在定义派生类对象时，构造函数的执行顺序为（e.g. 6.cpp）

      * 调用基类的构造函数，对基类数据成员初始化
      * 调用内嵌对象成员的构造函数，对内嵌成员的数据成员初始化
      * 执行派生类的构造函数体，对派生类数据成员初始化

      ➡撤销对象时，析构函数的调用顺序与构造函数的调用顺序正好相反：首先执行派生类的析构函数，然后执行内嵌对象成员的析构函数，最后执行基类的构造函数

    * 在派生类中含有多个内嵌对象成员时，调用内嵌对象成员的构造函数顺序由他们在类中声明的顺序确定（e.g. 7.cpp）

    * 如果派生类的积累也是一个派生类，**每个派生类只需负责其直接基类数据成员的初始化**



## 调整基类成员在派生类中的访问属性的其他方法

* 同名成员（e.g. 8.cpp）

  * 在定义派生类的时候，允许在派生类中说明的成员与基类中的成员名字相同，即派生类可以重新说明与基类成员同名的成员

  * 在派生类中定义了与基类成员同名的成员，则称派生类覆盖了基类的同名成员，在基类中使用这个名字意味着访问在派生类中重新说明的成员

  * 为了在派生类中使用基类同名的成员，必须在该成员名之前加上基类名和作用域标志符 "::"

  * 格式：

    `基类名::成员名`

* 访问声明（e.g. 9.cpp）



## 多重继承

